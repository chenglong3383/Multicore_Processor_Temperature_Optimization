function [Tpeak, Tvector, Tconv, TM] = FastBoundedPeakTemperature(TM, tslp, tact, skipCheck)
% [Tpeak, Tvector, Tconv, TM] = FastBoundedPeakTemperature(TM, tslp, tact)
%
% Function for calculating the Fast Bounded Peak Temperature of a multicore processor
% managed by Periodic Thermal Management
% Input:
% TM:   the thermal and power model of the processor, generated by
%       unction MultiCoreProcessorThermalModel
% tslp: a vector specifying the length of the PTM sleep intervals of all
%       cores
% tact: a vector specifying the length of the PTM active intervals of all
%       cores
%
% Output:
% Tpeak: the Accurate Neighbor Peak Temperature
% Tvector: the peak temperature of all cores
% Tconv: the thermal influence between cores
% TM:   the thermal and power model containing the calculating history. Use
%       it for future peak temperature calculating to speed up the program.
%
% Note: the order of cores in tslp and tact should be same with that in TM.
%       the time unit is milisecond!
if nargin < 4
    skipCheck = 0;
end

[flag, report] = checkInputsForPeakTemperatureComputing(TM, tslp, tact);
if flag == 0
    warning(report);
end

if flag < 0
    error(report, 0);
end


scalor          = 0.001; % 0.001 second, i.e., ms

%%
% since the thermal influences from non-core nodes have been considered in
% thermal model, only the thermal influences from cores should always been
% calculated
pTact = TM.p / scalor;          % the resolution of tact and tslp

%% isAct and isPeriodic
% indicates if Timp(i,j) can be skipped and if the
% impulse response from corresponding node is independent from tact and tslp;

isAct = ( tact >= pTact );
isPeriodic = isAct;
isPeriodic( tslp < pTact ) = false;



%% check if Timp already been calculated and calculate Timp
if ~skipCheck
    [TM] = completeTimp(TM, tslp, tact, isPeriodic, isAct, scalor);
end

%% calculate the temperature
[Tvector, Tconv] = computeTempUpperBound(TM, tslp, tact, isAct, isPeriodic);

[Tpeak, ~] = max(Tvector);


