function [Tpeak, TM] = CalculatePeakTemperature(TM, tslp, tact, scope, nodeIdx)
% [Tpeak, TM] = CalculatePeakTemperature(TM, tslp, tact)
% 
% Function for calculating the Peak Temperature of a multicore processor
% managed by Periodic Thermal Management 
% Input:
% TM:   the thermal and power model of the processor, generated by
%       unction MultiCoreProcessorThermalModel
% tslp: a vector specifying the length of the PTM sleep intervals of all
%       cores
% tact: a vector specifying the length of the PTM active intervals of all
%       cores
% scope: should be one of the following three types
%       'global': function behaves the same as function AccurateNeighborPeakTemperature
%       'single': only the peak temperature of [nodeIdx] will be calculated
%       'self':   only the peak temperature of [nodeIdx] will be
%       calculated, and other cores are in sleep state.
% nodeIdx: the index of the core whose peak temperature will be calculated
%       when scope is 'single' or 'self'.
% 
% Output:
% Tpeak: the Accurate Neighbor Peak Temperature
% TM:   the thermal and power model containing the calculating history. Use
%       it for future peak temperature calculating to speed up the program.
% 
% Note: the order of cores in tslp and tact should be same with that in TM.
%       the time unit is milisecond!


N               = TM.N;
p               = TM.p;
n               = TM.n;
fftLength       = TM.fftLength;
scalor          = 0.001; % unit ms

if ( max(TM.tend) + 2 * scalor * ( max(tact) + max(tslp) ) ) >= (fftLength * p - 5)
    error('Check the unit of tact and tslp!');
end



%%
% since only the thermal influences from non-core nodes have been considered in
% TM.Tconstmax, the thermal influences from cores should always been
% calculated
pTact           = p / scalor;          % the resolution of tact and tslp
validSource     = true(1, n);
validTarget     = false(1, n);
%% input cases1
switch scope
    case 'global'
        validTarget     = true(1, n);
    case 'single'
        if TM.isCore(nodeIdx) == 0
            error('Currently the thermal model can only be used for the temperature of nodes of core ');
        end
        validTarget(nodeIdx) = true;
    case 'self'
        %disp('self mode');
        if TM.isCore(nodeIdx) == 0
            error('Currently the thermal model can only be used for the temperature of nodes of core ');
        end
        if tact(nodeIdx) < pTact && tslp(nodeIdx) < pTact
            error('tact and tslp of the given node are less than the resolution');
        end
        validTarget(nodeIdx) = true;
        validSource     =   false(1,n);
        validSource(nodeIdx) = true;
        tact( [ 1:nodeIdx-1, nodeIdx+1:end] ) = 0;
        tslp( [ 1:nodeIdx-1, nodeIdx+1:end] ) = 0;
end

%% calculate

isAct = false( 1, n);
isAct( tact >= pTact ) = true;
validTarget = validTarget & isAct;

isPeriodic = isAct;
isPeriodic( tslp < pTact ) = false;
validSource = validSource & isPeriodic;


%% check if Timp already been calculated AND calculate Timp
[TM] = completeTimp(TM, tslp, tact, validSource, validTarget, scalor);


%% calculate the temperature
[ Temperature] = computeTemp(TM, tslp, tact, isAct, isPeriodic);


Tpeak = max(Temperature);

