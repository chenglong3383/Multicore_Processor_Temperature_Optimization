function [result, TM] = SubDeadlinePartitionBrutallySearching(problem, options)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% find the minimal peak temperature of a pipelined multicore processor
% under periodic thermal management with hard real-time
% guarantees by dividing the end-to-end deadline into a set of sub-deadlines
% and then seaching PTM for each sub-deadline.
%
% INPUT:
% problemï¼š A structure defining the peak temperature minimizing
%       problem, including below fields:
%       TM              the thermal and power model of the processor, generated by
%                       function MultiCoreProcessorThermalModel
%       config          A structure specifying other parameters of the
%                       pipelined system, including:
%           alpha       the upper and lower arrival curve of workload
%           deadline    the relative end to end deadline of the workload
%           wcets       a vector containing the worst case execution time
%                       of each sub-application on the activated cores
%           actcoreIdx  for a n-core processor, if we only activate part of the
%                       cores, the index of actived cores must be given.
%           tswons      switch on overhead of actived cores
%           tswoffs     switch off overhead of actived cores
%           activeNum   the number of actived cores
%
%options:  the configuration of the optimization algorithms, including:
%       verbose         level of verbosity (0: no output, 1: final,
%                       2: iter (default), 3: debug)
%       step            the step of the discretization of the searching
%                       space for brutally searching method, default: 1.
%
%OUTPUT:
%result: detailed info about the solution
%        optb           the optimal parameter b of the sub-problem
%        optrho         the optimal parameter \rho of the sub-problem
%        miniTpeak      the optimal peak temperature
%        solution       solution(1,:): toff,  solution(2,:): ton
%        kernel         optimization method
%        activeNum      the number of actived cores
%        exetime        the time expense of the optimization
%
%TM: an optional output. The outputed TM contains the updated impulse
%between nodes during optimization. Re-using it may speed up future
%peak tempearture optimization or calculating.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% check input arguments
tt =tic;
if (nargin<1)
    error('input arguments not enough');
end

TM = problem.TM;
config = problem.config;

[flag, report] = checkingArguments(config);
if flag == 0
    error(report);
end
[verbose, step] = processOptionsWithDefaults(options,...
    'verbose', 2, 'step', 1);
config.step = step;
if verbose >= 1
    fprintf(['\n\n\nStart Minimizing the Peak Temperature With Method: Sub-Deadline ', ...
        'Partition\n']);
end
%% shortcuts
n           = TM.n;
p           = TM.p;
sumWcet     = config.sumWcet;
tswoffs     = config.tswoffs;
tswons      = config.tswons;
wcets       = config.wcets;
sumTswon    = sum(config.tswons);
acn         = config.activeNum;
coreIdx     = config.actcoreIdx;
scalor1     = 0.001; % the unit of toff and ton, scale between ms and s
pToffTon    = p / scalor1;
deadline    = config.deadline;

%% initialize output
optTemp     = max(TM.T_inf_a);
optsolution = zeros(2, n);
optpartition = zeros(1, n);

%% pre-processing
feasibleDeadline = zeros(acn,2);
for i = 1 : acn
    feasibleDeadline(i, 1) = wcets(i) + tswons(i);
    feasibleDeadline(i, 2) = deadline - ( sumWcet + sumTswon - wcets(i) - tswons(i));
end

% get the deadline candidcates for every core
candidDeadline = cell(1, acn-1);
limit          = zeros( size(candidDeadline));
for i = 1 : acn-1
    % deadline candidcates
    candidDeadline{i} = feasibleDeadline(i, 1) : step : feasibleDeadline(i, 2);
    limit(i)          = size( candidDeadline{i}, 2 );
end

if min(limit)<1
    error('SDP: deadline too small');
end

% initialize the deadline index as [1,1,....,1]
deadlineIdx = ones(1, acn - 1);

% predict the number of total loops
total = 1;
for i = 1 : acn - 1
    total = total * limit(i);
end
if total < 5000
    numticks = 10;
else if total < 20000
        numticks = 100;
    else
        numticks = 200;
    end
end
disp_ticks = round(linspace(0, total, numticks));
percent_tick = linspace(0, 100, numticks);
tickid = 1;
% a counter

if verbose >= 2
    disp(['SDP: checking ', num2str(total, '%d'), ' sub-deadline combinations']);
end

count = 0;
%% continuely updating the deadline index and calculate the peak temperature

stop = 0;
isFast = false;
while ~stop
    
    % the deadline partition for current deadline index
    partition = zeros(1, acn);
    for i = 1 : acn-1
        partition(i) = candidDeadline{i}( deadlineIdx(i) );
    end
    partition(acn) = deadline - sum( partition(1 : acn-1) );
    
    % feasible
    % the feasible region of toffs
    fesibleToff = zeros(acn,2);
    %cand = cell(1,n);
    for j= 1 : acn
        fesibleToff(j,1) = tswoffs(j) + p;
        fesibleToff(j,2) = partition(j) - wcets(j) - tswons(j);
        % cand{j} = fesbl(j,1) : step :fesbl(j,2);
    end
    
    
    alpha_in = config.alpha;
    toffs = zeros(1, acn);
    tons  = zeros(1, acn);
    
    for k = 1 : acn
        
        %construct the demand service bound
        alpha_deadline = rtcaffine( alpha_in(1), 1 , partition(k));
        
        %for current core, k, we get the best toff and  ton where the peak
        %temprature when this core is actived is the
        %minimum
        [optToff, optTon, feasible, TM] = DPAPTM(alpha_deadline, ...
            fesibleToff(k,:), k, TM, config);
        
        if feasible == 0 % no solution is found
            break;
        end
        toffs(k) = optToff;
        tons(k) = optTon;
        if k < acn
            % calculate the output arrival curve for the next core
            tvld = max(round(tons(k) - tswons(k)), 1);
            beta = rtctdma( tvld, round(tons(k) + toffs(k)) , 1);
            bli = beta(2);
            %  bui = beta(1);
            bli = rtcrdivide(bli, wcets(k));
            % bui = rtcrdivide(bui, wcets(id));
            %save rtc bli alpha_in
            alpha_out = rtcmindeconv(alpha_in(1),bli);
            %alpha_out=rtcceil(rtcmin(rtcmindeconv(rtcminconv(alpha_in(1), bui), bli), bui));
            alpha_in = alpha_out;
        end
    end
    
    %         calculate tact and tslp for temperature calculating
    %         unit: msec
    if feasible
        [tact, tslp, tons]= prepareTacts(toffs, tons, config, false);
        [Tpeak, TM] = CalculatePeakTemperature(TM, tslp, tact,'global',[]);
        if Tpeak < optTemp
            optTemp = Tpeak;
            optsolution = [toffs; tons];
            optpartition = partition;
        end
    end
    
    % update the deadline index
    [deadlineIdx, flag] = updateIndex(acn-1, limit, deadlineIdx);
    count = count +1;
    if verbose >= 2 &&  count > disp_ticks(tickid) 
        disp(['SDP: complete ', num2str(percent_tick(tickid)), '%, current', ...
            ' best temperature ', num2str(optTemp, '%.3f'), ' (K)']);
        if tickid  < numticks
            tickid = tickid + 1;
        end
    end
    if flag
        stop = 1;
    end
end
optsolution = [optsolution;optpartition];
exetime = toc(tt);
if verbose >= 1
    fprintf(['Best Peak Temperature: ', num2str(optTemp, '%.3f'), ...
        '(K) found in ', num2str(exetime, '%.1f'), ' (s)\n']);
end

result = results(1,0.1,optTemp,optsolution,3,config.activeNum,...
    exetime);





