function [result, TM] = PayBurstOnlyOnceMinimizing(problem, options)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function [result, TM] = PayBurstOnlyOnceMinimizing(TM, config, kernel, stepb)
%
% find the minimal peak temperature of a pipelined multicore processor
% under periodic thermal management with hard real-time
% guarantees by using the pay burst only once principle.
%
% INPUT:
% problemï¼š A structure defining the peak temperature minimizing
%       problem, including below fields:
%       TM              the thermal and power model of the processor, generated by
%                       function MultiCoreProcessorThermalModel
%       config          A structure specifying other parameters of the
%                       pipelined system, including:
%           alpha       the upper and lower arrival curve of workload
%           deadline    the relative end to end deadline of the workload
%           wcets       a vector containing the worst case execution time
%                       of each sub-application on the activated cores
%           actcoreIdx  for a n-core processor, if we only activate part of the
%                       cores, the index of actived cores must be given.
%           tswons      switch on overhead of actived cores
%           tswoffs     switch off overhead of actived cores
%           activeNum   the number of actived cores
%
%options:  the configuration of the optimization algorithms, including:
%       verbose         level of verbosity (0: no output, 1: final,
%                       2: iter (default), 3: debug)
%       method          which method is adopted to solve the sub-problem,
%                       should be one of 'BS', 'FBGD'(default), and 'ANSA'
%       stepBSub        the step of the discretization of parameter b of the
%                       sub-problem, default: 1
%       step            the step of the discretization of the searching
%                       space for brutally searching method, default: 1.
%       san             the times that the Accurate Neighbor Simulated
%                       Annealing method will be repeated 
%
% OUTPUT:
%result: detailed info about the solution
%        optb           the optimal parameter b of the sub-problem
%        optrho         the optimal parameter \rho of the sub-problem
%        miniTpeak      the optimal peak temperature
%        solution       solution(1,:): toff,  solution(2,:): ton
%        kernel         optimization method
%        activeNum      the number of actived cores
%        exetime        the time expense of the optimization
%
%TM: an optional output. The outputed TM contains the updated impulse
%between nodes during optimization. Re-using it may speed up future
%peak tempearture optimization or calculating.
%
% author:       Long Cheng
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Checking input arguments
if (nargin < 1)
    error('input arguments not enough');
end

TM          = problem.TM;
config      = problem.config;
config.N    = TM.N;
config.n    = TM.n;
[flag, report] = checkingArguments(config);
if flag == 0
    error(report);
end

if nargin < 2
    options = [];
end


[verbose, method, stepBsub, step, san] = processOptionsWithDefaults(options,...
    'verbose', 2, 'method', 'FBGD', 'stepBSub', 1, 'step', 1, 'san', 4);

method = upper(method);
allMethods = {'BS', 'FBGD', 'ANSA'};
if ~ismember(method, allMethods)
    error('method set error in options, must be one of ''BS'', ''FBGD'', and ''ANSA''');
end
for i = 1:numel(allMethods)
   if strcmp(method, allMethods{i})
       kernel = i;
       break;
   end
end

step = max(1, ceil(step(1)));
stepBsub = max(1, ceil(stepBsub(1)));
verbose = ceil(verbose);
config.step = step;
config.verbose = verbose;
config.san = san;

%% some shortcuts
activeNum   = config.activeNum;
maxWcets    = max(config.wcets);
% demand service curve
beta        = rtcaffine(config.alpha(1), 1, config.deadline);
% find the feasible region of b
b_min       = config.sumWcet + config.sumTswoff;
minSlope    = 1 / maxWcets;
b_max       = minbdf_WCET(beta, 0 , minSlope);

if b_max <= b_min
    error('PayBurstOnlyOnceMinimizing: deadline too small');
end

% initialize
optTemp     = max(TM.T_inf_a);
optsolution = zeros(1, activeNum);
opt_b       = inf;
opt_rho     = 0.999;
methods = {'Brutally Searching', 'Fast Bounded Greedy Descending',...
    'Accurate Neighbor Simulated Annealing'};

if verbose >= 1
    fprintf(['\n\n\nStart Minimizing the Peak Temperature With Method: ', ...
        methods{kernel}, '\n']);
end

%% test all the possible values of b step by step
timer1 = tic;
for b = b_min : stepBsub : b_max
    rho = minspeedbdfEDG(beta, b);
    if verbose >= 2
        fprintf(['solving the sub-problem for b = ', num2str(b,'%.2f'), ' and \\rho = ',...
            num2str(rho,'%.4f'), '\n']);
    end
    if rho * maxWcets >= 0.98
        continue;
    end
    dynamicData = makedata('b', b,'rho',rho, 'kernel', kernel);
    dynamicData.lseOffset = 350;
    dynamicData.lseK = 6;
    [miniTpeak, solution, TM] = PBOOsubStep(dynamicData, config, TM);
    if miniTpeak < optTemp
        optTemp = miniTpeak;
        optsolution = solution;
        opt_b = b;
        opt_rho = rho;
    end
end
exetime = toc(timer1);

if verbose >= 1
    fprintf(['Best Peak Temperature: ', num2str(optTemp, '%.3f'), ...
        '(K) found in ', num2str(exetime, '%.1f'), ' (s), with b = ',...
        num2str(b,'%.2f'), ' and \\rho = ', num2str(rho,'%.4f'), '\n']);
end

result = results(opt_b,opt_rho,optTemp,optsolution,kernel,config.activeNum,...
    exetime);

